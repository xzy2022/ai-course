# 第五章：局部搜索和约束满足问题

本章实现使用局部搜索方法求解数独问题的程序，展示约束满足问题（CSP）的解决思路。

## 文件说明

1. **sudoku_solver.py** - 9×9数独求解器
   - 实现完整的数独规则（行、列、宫唯一性约束）
   - 使用最小冲突数算法（Min-Conflicts）
   - 包含形式化约束检查

2. **sudoku_simple.py** - 4×4简化数独求解器
   - 更容易解决的示例，用于演示算法效果
   - 同样实现所有数独约束规则
   - 适合学习和理解算法原理

## 数独的形式化规则定义

### 基本集合
- 位置集合：G = {1, 2, ..., 9}（行和列的索引）
- 数字集合：N = {1, 2, ..., 9}（可填入的数字）

### 三个核心约束条件

1. **行唯一性约束**
   ```
   ∀i ∈ G, ∀j₁, j₂ ∈ G, j₁ ≠ j₂: S(i,j₁) ≠ S(i,j₂)
   ```
   每一行中的每个数字恰好出现一次

2. **列唯一性约束**
   ```
   ∀j ∈ G, ∀i₁, i₂ ∈ G, i₁ ≠ i₂: S(i₁,j) ≠ S(i₂,j)
   ```
   每一列中的每个数字恰好出现一次

3. **宫唯一性约束**
   ```
   ∀bᵣ, b꜀ ∈ {0,1,2}, ∀k ∈ N, ∃! (i,j) ∈ Box(bᵣ,b꜀): S(i,j) = k
   ```
   每个3×3的宫内，每个数字恰好出现一次

## 算法实现

### 最小冲突数算法（Min-Conflicts）

1. **初始化**：为每个空格随机分配一个有效数字
2. **冲突检测**：检查违反约束的单元格
3. **冲突解决**：选择冲突单元格，用产生最少冲突的值替换
4. **迭代优化**：重复步骤2-3直到没有冲突或达到最大迭代次数

### 核心方法

- `get_valid_numbers(row, col)`: 获取有效数字（不违反约束）
- `count_conflicts(row, col, value)`: 计算冲突数
- `get_conflicted_cells()`: 获取所有冲突单元格
- `verify_solution()`: 验证解的正确性

## 运行示例

### 4×4数独（推荐用于演示）
```bash
python sudoku_simple.py
```

示例输入：
```
| 1  2 | .  . |
| 3  . | .  . |
| .  . | 1  . |
| .  . | .  2 |
```

输出结果：
```
| 1  2 | 4  3 |
| 3  4 | 2  1 |
| 2  3 | 1  4 |
| 4  1 | 3  2 |
```

### 9×9数独（更复杂）
```bash
python sudoku_solver.py
```

## 特点

1. **形式化约束检查**：严格按照数独的数学定义实现约束
2. **可视化显示**：使用颜色区分原始数字（蓝色）和求解填入的数字（红色）
3. **多次尝试机制**：通过多次随机初始化提高成功率
4. **解的正确性验证**：自动验证找到的解是否满足所有约束

## 算法优缺点

### 优点
- 实现简单，易于理解
- 对于中等难度的问题有效
- 不需要回溯，内存占用小

### 缺点
- 不能保证找到解（概率性算法）
- 对于复杂问题可能需要多次尝试
- 可能陷入局部最优

## 学习要点

1. **约束满足问题**的理解和建模
2. **局部搜索算法**的基本原理
3. **冲突函数**的设计和优化
4. **形式化方法**在算法实现中的应用

## 扩展思路

1. 添加更智能的初始化策略
2. 实现禁忌搜索（Tabu Search）避免循环
3. 结合模拟退火算法提高收敛性
4. 添加启发式规则加速收敛