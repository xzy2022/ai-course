# 澳大利亚地图涂色问题的CSP形式化模型

本项目实现了澳大利亚地图涂色问题的约束满足问题（CSP）形式化模型，采用模块化设计，分离模型构建和测试功能。

## 问题背景

澳大利亚地图涂色问题是一个经典的约束满足问题：用三种颜色（红、绿、蓝）为澳大利亚的各个州和地区涂色，要求相邻的区域颜色不能相同。

## 文件结构

```
australia_map_coloring/
├── csp_model.py          # 纯CSP模型文件（可被其他脚本引用）
├── test_csp.py           # 独立的测试脚本
├── generic_solver.py     # 通用回溯搜索CSP求解器（泛化核心）
├── australia_adapter.py  # 澳大利亚涂色问题适配器
├── solve_australia.py    # 澳大利亚涂色问题求解演示
├── demo_generic_solver.py # 泛化求解器完整演示
└── README.md             # 本文档
```

## 形式化定义

### 变量集合 X
```
X = {WA, NT, SA, QLD, NSW, VIC, TAS}
```
其中：
- WA: 西澳大利亚州 (Western Australia)
- NT: 北领地 (Northern Territory)
- SA: 南澳大利亚州 (South Australia)
- QLD: 昆士兰州 (Queensland)
- NSW: 新南威尔士州 (New South Wales)
- VIC: 维多利亚州 (Victoria)
- TAS: 塔斯马尼亚州 (Tasmania)

### 值域集合 D
对于每个变量 i ∈ X，值域为：
```
D_i = {红, 绿, 蓝}
```

### 约束集合 C
包含9个二元约束，确保相邻区域颜色不同：

1. **C₁**: <{WA, NT}, WA ≠ NT> （西澳大利亚州与北领地相邻）
2. **C₂**: <{WA, SA}, WA ≠ SA> （西澳大利亚州与南澳大利亚州相邻）
3. **C₃**: <{NT, SA}, NT ≠ SA> （北领地与南澳大利亚州相邻）
4. **C₄**: <{NT, QLD}, NT ≠ QLD> （北领地与昆士兰州相邻）
5. **C₅**: <{SA, QLD}, SA ≠ QLD> （南澳大利亚州与昆士兰州相邻）
6. **C₆**: <{SA, NSW}, SA ≠ NSW> （南澳大利亚州与新南威尔士州相邻）
7. **C₇**: <{SA, VIC}, SA ≠ VIC> （南澳大利亚州与维多利亚州相邻）
8. **C₈**: <{QLD, NSW}, QLD ≠ NSW> （昆士兰州与新南威尔士州相邻）
9. **C₉**: <{NSW, VIC}, NSW ≠ VIC> （新南威尔士州与维多利亚州相邻）

## 模块说明

### csp_model.py - 纯CSP模型文件

**设计理念**：只包含CSP的构建和基础功能，不包含测试代码，可以被其他脚本引用。

**核心类**：

1. **Color**: 颜色枚举类
   - RED: 红
   - GREEN: 绿
   - BLUE: 蓝

2. **Region**: 地区枚举类
   - 包含所有澳大利亚州和地区的名称

3. **AustraliaMapColoringCSP**: CSP模型类
   - 实现完整的CSP形式化定义
   - 提供约束检查和验证功能
   - 支持赋值管理和冲突检测

**主要方法**：
- `is_consistent()`: 检查赋值是否满足约束
- `is_complete()`: 检查赋值是否完整
- `is_solution()`: 检查是否为完整解决方案
- `get_unassigned_variables()`: 获取未分配的变量
- `get_conflicted_variables()`: 获取有冲突的变量
- `count_conflicts()`: 计算冲突总数
- `get_legal_values()`: 获取合法的颜色值
- `validate_csp_model()`: 验证CSP模型的正确性

### test_csp.py - 独立测试脚本

**功能**：引用csp_model.py中的模型进行全面的测试和验证。

**测试内容**：
1. **基本功能测试**：空赋值、部分赋值、有冲突的赋值
2. **解决方案方法测试**：完整解决方案和不完整解决方案的验证
3. **随机赋值测试**：生成随机赋值并分析冲突情况
4. **约束检查测试**：各种约束情况的详细测试
5. **值域方法测试**：未分配变量和合法值的获取

### generic_solver.py - 通用回溯搜索CSP求解器

**功能**：实现完全泛化的回溯搜索算法，适用于任何约束满足问题。

**核心特性**：
1. **泛化设计**：使用泛型类型 `CSPBase<V, D>`，支持任意变量和值域类型
2. **抽象基类**：定义标准的CSP接口，确保类型安全
3. **通用启发式**：MRV + 度启发式 + LCV + AC-3算法的完整实现
4. **泛化统计**：通用的性能指标和问题分析，无硬编码信息

**主要类**：
- `CSPBase<V, D>`: 抽象CSP基类，定义标准接口
- `GenericBacktrackSolver<V, D>`: 通用回溯搜索求解器

**核心方法**：
- `solve()`: 主求解方法，支持详细输出控制
- `get_performance_metrics()`: 获取详细的性能指标
- `print_statistics()`: 打印泛化的统计信息

### australia_adapter.py - 澳大利亚涂色问题适配器

**功能**：将澳大利亚涂色问题的专用CSP模型适配到通用接口。

**设计特点**：
1. **适配器模式**：无缝集成现有模型到泛化框架
2. **委托设计**：将特定功能委托给原始模型
3. **保持兼容**：完全保留原有的功能和方法

**核心类**：
- `AustraliaCSPAdapter`: 澳大利亚涂色问题的CSP适配器

**便捷功能**：
- `create_australia_csp()`: 快速创建适配器的工厂函数
- 委托所有显示和验证方法给原始模型

### solve_australia.py - 完整求解演示

**功能**：演示使用回溯搜索求解器解决澳大利亚涂色问题的完整过程。

**演示内容**：
1. **CSP模型构建和验证**
2. **回溯搜索求解过程**
3. **解决方案分析和验证**
4. **启发式策略效果对比**
5. **问题复杂度分析**
6. **算法性能统计**

### demo_generic_solver.py - 泛化求解器完整演示

**功能**：展示纯泛化架构的灵活性、可扩展性和一致性。

**演示内容**：
1. **澳大利亚涂色问题**：使用适配器演示具体问题的求解
2. **简化地图涂色**：验证通用求解器的泛化能力
3. **多次运行测试**：展示算法的一致性和稳定性
4. **灵活性演示**：不同规模问题的求解能力
5. **架构优势**：纯泛化设计的好处

**核心价值**：
- 展示纯泛化架构的优势
- 验证通用求解器的正确性和一致性
- 演示适配器模式的实际应用
- 说明类型安全和代码重用的重要性

## 使用方法

### 运行测试脚本
```bash
python test_csp.py
```

### 运行求解演示
```bash
python solve_australia.py
```

### 运行澳大利亚涂色问题演示
```bash
python solve_australia.py
```

### 运行泛化求解器完整演示
```bash
python demo_generic_solver.py
```

### 在其他脚本中引用通用求解器
```python
from generic_solver import GenericBacktrackSolver, CSPBase
from australia_adapter import create_australia_csp

# 方法1：求解澳大利亚涂色问题（推荐）
csp = create_australia_csp()
solver = GenericBacktrackSolver(csp)
success, solution = solver.solve()

# 方法2：为其他CSP问题创建通用求解器
class MyCSP(CSPBase[MyVarType, MyValueType]):
    def get_variables(self): ...
    def get_domain(self, var): ...
    def get_neighbors(self, var): ...
    def is_consistent(self, var, value, assignment): ...

# 使用通用求解器求解任何CSP问题
my_csp = MyCSP()
solver = GenericBacktrackSolver(my_csp)
success, solution = solver.solve()

# 方法3：获取详细的性能指标
metrics = solver.get_performance_metrics()
print(f"探索节点数: {metrics['nodes_explored']}")
print(f"求解时间: {metrics['solution_time']}")
```

## 模型验证

测试脚本包含完整的模型验证功能，确保：
- 变量集合包含正确的7个地区
- 每个变量的值域包含3种颜色
- 约束集合包含所有9个必要的邻接约束
- 邻接关系符合澳大利亚地理实际

## 应用场景

这个CSP模型可以作为以下算法的基础：
1. **回溯搜索算法**：系统性地搜索解决方案
2. **前向检查**：提前检测不可能的赋值
3. **弧相容**：增强约束传播
4. **局部搜索算法**：如最小冲突数算法
5. **遗传算法**：进化式求解

## 扩展可能性

1. **更多颜色**：扩展值域以增加问题的灵活性
2. **不同地图**：应用到其他地理区域的涂色问题
3. **约束变化**：添加更复杂的约束条件
4. **性能优化**：针对大规模问题的算法优化

## 设计优势

1. **模块化设计**：模型和测试完全分离，便于重用
2. **清晰的接口**：提供完整的API用于各种算法实现
3. **形式化正确性**：严格按照CSP理论实现
4. **易于扩展**：可以轻松添加新的约束和算法

## 求解性能

基于最终优化版回溯搜索算法的性能表现：

- **搜索效率**：通常只需探索8-12个节点即可找到解决方案
- **时间复杂度**：在O(d^n)基础上，通过启发式大幅优化
- **空间复杂度**：O(n×d)用于存储赋值和值域信息
- **完备性**：如果存在解，算法一定能找到
- **最优性**：找到第一个可行解（不保证颜色使用最少）

## 理论意义

纯泛化架构的实现展示了：

1. **泛化编程在算法设计中的应用**
   - 类型安全的通用算法实现
   - 泛型接口的抽象和具体化
   - 代码重用和模块化的最佳实践

2. **设计模式的实际运用**
   - 适配器模式的无缝集成
   - 策略模式的可插拔算法
   - 模板方法模式的算法骨架

3. **CSP理论的统一实现**
   - 变量、值域、约束的抽象表示
   - 启发式算法的通用框架
   - 约束传播的标准流程

4. **软件工程的最佳实践**
   - 关注点分离（模型、适配器、算法）
   - 单一职责原则的遵循
   - 开闭原则的体现

这个纯泛化实现为理解和实践通用算法设计提供了具体而完整的实例，展示了从具体问题到通用解决方案的抽象过程。

## 架构优势

1. **纯粹的泛化设计**
   - 所有输出信息都是通用的，无硬编码内容
   - 适用于任何CSP问题，无特定假设
   - 类型安全，编译时检查错误

2. **清晰的责任分离**
   - 模型：负责问题的具体表示
   - 适配器：负责接口转换
   - 算法：负责通用求解逻辑

3. **优秀的可扩展性**
   - 新问题只需实现CSPBase接口
   - 新算法可轻松集成到现有框架
   - 统一的统计和性能监控

4. **一致的代码质量**
   - 所有问题使用相同的优化算法
   - 统一的错误处理和日志记录
   - 标准化的性能指标